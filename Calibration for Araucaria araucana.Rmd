---
title: "Calibration for *Araucaria araucana*"
output:
  pdf_document:
    pandoc_args: --listings
    includes:
      in_header: preamble.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is an example of the simple NLME model of *Araucaria araucana* being calibrated in a new stand first and then tree height predicted using the calibrated NLME model for the new stand. In this example, the new stand is stand 2 in the validating database.

&nbsp;

## Packages involved in the calibration

```{r Package, message=FALSE, warning=FALSE}
library(nlme)
library(dplyr)
```

&nbsp;

## Calibration and height prediction

* Simple NLME model developed (SMAA)

```{r simple NLME model}
Fitting_AA <- read.csv("Anpassung_AA.csv")
colnames(Fitting_AA) <- c('Nr.', 'Site', 'Stand', 'Plot', 'Species', 'd', 'h')

SMAA <- nlme(h ~ 1.3 + a * exp(-b * exp(-c * d)),start = c(a = 46.410000000, b = 2.174185939, c = 0.008847333), data = Fitting_AA, fixed = a + b + c ~ 1, random = a ~ 1 | Stand, weights = varPower(form = ~ d))

print(SMAA)
```

* Calling the data in SMAA

All results are printed so that you can use them in your stand or plot.

```{r}
.G <- VarCorr(SMAA, rdig = 7) # read variance and correlation components
print(.G)

.estimate <- as.numeric(.G[, 1])
print(.estimate)

.cov_parm <- c('var_u', 'Residual')
print(.cov_parm)

.CEP <- data.frame(.cov_parm, .estimate)
print(.CEP)

var_e <- .CEP[2, 2] # sigma^2:the scaling factor, given by the value of the residual variance of the model
print(var_e)

D <- .CEP[1, 2] # D: the structure of the variance-covariance matrix among stands, since there is only one random parameter in SMAA, D is the variance of this parameter
print(D)

parms <- data.frame(t(SMAA$coefficients$fixed)) # estimated values for the fixed parameters of SMAA
print(parms)

rho <- coef(SMAA$modelStruct$varStruct, un = FALSE) # the coefficient of the variance function
print(rho)
```

* Calibration

Stand 2 in the validating database is used as the new stand in this example. For the simple NLME model, the calibration design is a random selection of 5 trees, so now we create two datasets, one with 5 sample trees in stand 2 and the other with those trees in stand 2 other than the five sample trees.

```{r Input}
sample_d <- c(58, 139, 73, 207, 166)
sample_h <- c(18, 25, 21, 34, 36)
sample <- data.frame(sample_d, sample_h)

other_d <- c(57, 139, 139, 33, 61, 81, 166, 52, 207, 207, 166, 207, 166, 98.7, 33, 207, 89)
other_h <- c(13, 25, 25, 13, 16, 30, 36, 13, 44, 44, 36, 34, 36, 22, 28, 34,20) # for your new stand, heights are not needed here, I am only showing them here to show you the predictive performance of the calibrated model in this example
other <- data.frame(other_d, other_h)
```

```{r Calibration}
matcor <- diag((sample$sample_d) ^ (2 * rho), ncol = 5, nrow = 5) # Gi: diagonal matrix describing the nonconstant variance
r = var_e * matcor # Ri: within-stand variance-covariance matrix
y <- as.matrix(sample$sample_h)
Z <- as.matrix(exp(-parms$b * exp(-parms$c * sample$sample_d))) # the partial derivatives with respect to random parameters
fxBb <- as.matrix(1.3 + (parms$a) * exp(-parms$b * exp(-parms$c * sample$sample_d))) # the estimated tree height only with fixed effects
bi <- D %*% t(Z) %*% solve(r + Z %*% D %*% t(Z)) %*% ((y - fxBb)) # the estimated value of the random parameter --> Eq.24 in text
print(bi)
```

* height prediction

```{r height prediction, warning=FALSE}
other$pre.h <- 1.3 + parms$a * exp(-parms$b * exp(-parms$c * other$other_d)) + bi * exp(-parms$b * exp(-parms$c * other$other_d)) # Eq.25 in text
print(other)
```
